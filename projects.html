<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Projects | Jesse Zumstein</title>
    <!-- Rive Runtime -->
    <script src="https://unpkg.com/@rive-app/canvas@latest"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            background: #0a0a0a;
            color: #ffffff;
            line-height: 1.6;
        }

        nav {
            position: fixed;
            top: 0;
            width: 100%;
            background: rgba(26, 26, 46, 0.95);
            backdrop-filter: blur(10px);
            padding: 20px 0;
            z-index: 1000;
            border-bottom: 1px solid rgba(102, 126, 234, 0.2);
        }

        nav .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 0 20px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        nav .logo {
            font-size: 1.5em;
            font-weight: 700;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            text-decoration: none;
        }

        nav ul {
            display: flex;
            list-style: none;
            gap: 35px;
        }

        nav a {
            color: #a8b2d1;
            text-decoration: none;
            font-size: 1.05em;
            transition: color 0.3s;
        }

        nav a:hover {
            color: #64ffda;
        }

        .hero-section {
            padding: 150px 20px 80px;
            background: linear-gradient(135deg, #1a1a2e 0%, #0f0f1e 100%);
            position: relative;
            overflow: hidden;
        }

        #heroCanvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 0;
        }

        .hero-content {
            max-width: 900px;
            margin: 0 auto;
            position: relative;
            z-index: 1;
            text-align: center;
        }

        h1 {
            font-size: 3.5em;
            margin-bottom: 20px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            position: relative;
            cursor: default;
        }

        h1::before {
            content: attr(data-text);
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: radial-gradient(
                circle 150px at var(--mouse-x, 50%) var(--mouse-y, 50%),
                rgba(255, 255, 255, 0.8) 0%,
                rgba(102, 126, 234, 0.6) 30%,
                transparent 70%
            );
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            opacity: 0;
            transition: opacity 0.3s;
            pointer-events: none;
        }

        h1:hover::before {
            opacity: 1;
        }

        .subtitle {
            font-size: 1.3em;
            color: #a8b2d1;
            margin-bottom: 30px;
        }

        #projectsCanvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 0;
            opacity: 0.4;
            pointer-events: none;
        }

        .filter-section {
            background: #0f0f1e;
            padding: 40px 20px;
            border-bottom: 1px solid rgba(102, 126, 234, 0.1);
            position: relative;
            z-index: 1;
        }

        .filter-container {
            max-width: 1200px;
            margin: 0 auto;
            display: flex;
            justify-content: center;
            gap: 15px;
            flex-wrap: wrap;
        }

        .filter-btn {
            background: rgba(30, 30, 63, 0.5);
            color: #a8b2d1;
            border: 1px solid rgba(102, 126, 234, 0.3);
            padding: 12px 25px;
            border-radius: 25px;
            cursor: pointer;
            transition: all 0.3s;
            font-size: 1em;
        }

        .filter-btn:hover,
        .filter-btn.active {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border-color: transparent;
        }

        .projects-content {
            max-width: 1200px;
            margin: 80px auto;
            padding: 0 20px;
            position: relative;
            z-index: 1;
        }

        .project-showcase {
            margin-bottom: 80px;
        }

        .project-large {
            display: grid;
            grid-template-columns: 1.2fr 1fr;
            gap: 50px;
            background: linear-gradient(135deg, #1e1e3f 0%, #1a1a2e 100%);
            border-radius: 25px;
            overflow: hidden;
            border: 1px solid rgba(102, 126, 234, 0.2);
            margin-bottom: 50px;
        }

        .project-large:nth-child(even) {
            grid-template-columns: 1fr 1.2fr;
        }

        .project-large:nth-child(even) .project-image {
            order: 2;
        }

        .project-image {
            position: relative;
            overflow: hidden;
        }

        .project-image img {
            width: 100%;
            height: 100%;
            object-fit: cover;
            transition: transform 0.5s;
        }

        .project-large:hover .project-image img {
            transform: scale(1.05);
        }

        .project-details {
            padding: 50px;
            display: flex;
            flex-direction: column;
            justify-content: center;
        }

        .project-category {
            color: #667eea;
            font-size: 0.9em;
            font-weight: 600;
            margin-bottom: 10px;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .project-details h2 {
            font-size: 2.2em;
            color: #64ffda;
            margin-bottom: 15px;
        }

        .project-role {
            color: #8892b0;
            font-size: 1.1em;
            margin-bottom: 20px;
        }

        .project-description {
            color: #a8b2d1;
            line-height: 1.9;
            font-size: 1.05em;
            margin-bottom: 25px;
        }

        .project-tech {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            margin-bottom: 25px;
        }

        .tech-tag {
            background: rgba(100, 255, 218, 0.1);
            color: #64ffda;
            padding: 8px 16px;
            border-radius: 20px;
            font-size: 0.9em;
            border: 1px solid rgba(100, 255, 218, 0.3);
        }

        .project-stats {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 20px;
            margin-top: 25px;
        }

        .stat-box {
            background: rgba(26, 26, 46, 0.5);
            padding: 15px;
            border-radius: 10px;
            border-left: 3px solid #667eea;
        }

        .stat-label {
            color: #8892b0;
            font-size: 0.85em;
            margin-bottom: 5px;
        }

        .stat-value {
            color: #64ffda;
            font-size: 1.3em;
            font-weight: 700;
        }

        .projects-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(320px, 1fr));
            gap: 35px;
        }

        .project-card {
            background: linear-gradient(135deg, #1e1e3f 0%, #1a1a2e 100%);
            border-radius: 20px;
            overflow: hidden;
            border: 1px solid rgba(102, 126, 234, 0.2);
            transition: all 0.4s;
        }

        .project-card:hover {
            transform: translateY(-10px);
            box-shadow: 0 20px 50px rgba(102, 126, 234, 0.4);
        }

        .project-card-image {
            height: 250px;
            overflow: hidden;
            position: relative;
        }

        .project-card-image img {
            width: 100%;
            height: 100%;
            object-fit: cover;
            transition: transform 0.4s;
        }

        .project-card:hover .project-card-image img {
            transform: scale(1.1);
        }

        .project-card-content {
            padding: 25px;
        }

        .project-card-content .project-category {
            font-size: 0.8em;
        }

        .project-card-content h3 {
            color: #64ffda;
            font-size: 1.4em;
            margin-bottom: 8px;
        }

        .project-card-content p {
            color: #8892b0;
            font-size: 0.95em;
            margin-bottom: 15px;
        }

        footer {
            background: #1a1a2e;
            padding: 40px 20px;
            text-align: center;
            color: #8892b0;
            border-top: 1px solid rgba(102, 126, 234, 0.1);
            position: relative;
            z-index: 1;
        }

        /* Rive Prototype Styles */
        .project-image .rive-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            align-items: stretch;
            justify-content: stretch;
            background: transparent;
            overflow: hidden;
        }

        /* Make project-image a positioning context for the Rive container */
        .project-large .project-image:has(.rive-container) {
            min-height: 500px;
        }

        #rive-canvas {
            width: 100%;
            height: 100%;
            cursor: pointer;
        }

        .rive-loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #667eea;
            font-size: 1.2em;
            opacity: 0.7;
            pointer-events: none;
        }

        .rive-error {
            color: #ff6b6b;
            text-align: center;
            padding: 20px;
        }

        @media (max-width: 968px) {
            .project-large,
            .project-large:nth-child(even) {
                grid-template-columns: 1fr;
            }

            .project-large:nth-child(even) .project-image {
                order: 0;
            }

            .project-stats {
                grid-template-columns: 1fr;
            }

            h1 {
                font-size: 2.5em;
            }

            .project-large .project-image:has(.rive-container) {
                min-height: 450px;
            }
        }
    </style>
</head>
<body>
    <nav>
        <div class="container">
            <a href="index.html" class="logo">JZ</a>
            <ul>
                <li><a href="index.html">Home</a></li>
                <li><a href="about.html">About</a></li>
                <li><a href="projects.html">Projects</a></li>
                <li><a href="contact.html">Contact</a></li>
            </ul>
        </div>
    </nav>

    <section class="hero-section">
        <canvas id="heroCanvas"></canvas>
        <div class="hero-content">
            <h1 id="mainTitle" data-text="Featured Projects">Featured Projects</h1>
            <p class="subtitle">AAA games, immersive experiences, and technical innovations</p>
        </div>
    </section>

    <section class="projects-content">
        <canvas id="projectsCanvas"></canvas>
        <div class="project-showcase">
            <!-- Rive Prototype Section -->
            <div class="project-large">
                <div class="project-image">
                    <div class="rive-container">
                        <div class="rive-loading" id="rive-loading">Loading prototype...</div>
                        <canvas id="rive-canvas"></canvas>
                    </div>
                </div>
                <div class="project-details">
                    <div class="project-category">Interactive Prototype</div>
                    <h2>Duo Prototype</h2>
                    <p class="project-role">Interactive Animation & State Machine Design</p>
                    <p class="project-description">An interactive prototype built with Rive, featuring state machine-driven animations. Hover and click on the canvas to explore the different states and transitions. This demonstrates real-time interactive graphics that respond to user input.</p>
                    <div class="project-tech">
                        <span class="tech-tag">Rive</span>
                        <span class="tech-tag">State Machines</span>
                        <span class="tech-tag">Interactive Animation</span>
                        <span class="tech-tag">Web Integration</span>
                    </div>
                    <div class="project-stats">
                        <div class="stat-box">
                            <div class="stat-label">Technology</div>
                            <div class="stat-value">Rive</div>
                        </div>
                        <div class="stat-box">
                            <div class="stat-label">Type</div>
                            <div class="stat-value">Interactive</div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="project-large">
                <div class="project-image">
                    <img src="images/HL_web.jpg" alt="Hogwarts Legacy">
                </div>
                <div class="project-details">
                    <div class="project-category">AAA Game Development</div>
                    <h2>Hogwarts Legacy</h2>
                    <p class="project-role">Cinematic Assembly</p>
                    <p class="project-description">Contributed to the cinematic pipeline for one of 2023's most anticipated AAA titles. Assembled complex cinematic sequences, optimized performance, and collaborated with the Frame Machine team to deliver stunning storytelling moments in the Wizarding World.</p>
                    <div class="project-tech">
                        <span class="tech-tag">Unreal Engine 5</span>
                        <span class="tech-tag">Sequencer</span>
                        <span class="tech-tag">Cinematics</span>
                        <span class="tech-tag">Pipeline Tools</span>
                    </div>
                    <div class="project-stats">
                        <div class="stat-box">
                            <div class="stat-label">Release Year</div>
                            <div class="stat-value">2023</div>
                        </div>
                        <div class="stat-box">
                            <div class="stat-label">Players</div>
                            <div class="stat-value">15M+</div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="project-large">
                <div class="project-image">
                    <img src="images/FF_web.jpg" alt="Fortnite">
                </div>
                <div class="project-details">
                    <div class="project-category">Live Service Game</div>
                    <h2>Fortnite & Fortnite Festival</h2>
                    <p class="project-role">Blueprinting & Character Rigging</p>
                    <p class="project-description">Developed Blueprint systems and rigged characters for Epic Games' flagship battle royale and its music-driven spin-off. Worked on performance optimization, character systems, and ensured seamless integration of new content for millions of daily players.</p>
                    <div class="project-tech">
                        <span class="tech-tag">Blueprints</span>
                        <span class="tech-tag">Character Rigging</span>
                        <span class="tech-tag">Maya</span>
                        <span class="tech-tag">Live Ops</span>
                    </div>
                    <div class="project-stats">
                        <div class="stat-box">
                            <div class="stat-label">Active Players</div>
                            <div class="stat-value">500M+</div>
                        </div>
                        <div class="stat-box">
                            <div class="stat-label">Platform</div>
                            <div class="stat-value">Cross-platform</div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="project-large">
                <div class="project-image">
                    <img src="images/MK_web.jpg" alt="Mortal Kombat">
                </div>
                <div class="project-details">
                    <div class="project-category">Mobile AAA</div>
                    <h2>Mortal Kombat Onslaught</h2>
                    <p class="project-role">Mocap Retargeting & Character Rigging</p>
                    <p class="project-description">Retargeted motion capture data and rigged iconic Mortal Kombat characters for NetherRealm's mobile fighting experience. Optimized rigs for mobile performance while maintaining the brutal, fluid combat the franchise is known for.</p>
                    <div class="project-tech">
                        <span class="tech-tag">Maya</span>
                        <span class="tech-tag">Motion Capture</span>
                        <span class="tech-tag">Retargeting</span>
                        <span class="tech-tag">Mobile Optimization</span>
                    </div>
                    <div class="project-stats">
                        <div class="stat-box">
                            <div class="stat-label">Characters Rigged</div>
                            <div class="stat-value">20+</div>
                        </div>
                        <div class="stat-box">
                            <div class="stat-label">Studio</div>
                            <div class="stat-value">NetherRealm</div>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <h2 style="font-size: 2.5em; color: #ccd6f6; text-align: center; margin-bottom: 50px;">More Projects</h2>

        <div class="projects-grid">
            <div class="project-card">
                <div class="project-card-image">
                    <img src="images/Lego_web.jpg" alt="Lego 2K Drive">
                </div>
                <div class="project-card-content">
                    <div class="project-category">Racing Game</div>
                    <h3>Lego 2K Drive</h3>
                    <p>Cinematic assembly and vehicle rigging for the open-world kart racing game</p>
                    <div class="project-tech">
                        <span class="tech-tag">Unreal Engine</span>
                        <span class="tech-tag">Sequencer</span>
                        <span class="tech-tag">Maya</span>
                        <span class="tech-tag">Rigging</span>
                    </div>
                </div>
            </div>

            <div class="project-card">
                <div class="project-card-image">
                    <img src="images/NTVRK_web.jpg" alt="Netvrk">
                </div>
                <div class="project-card-content">
                    <div class="project-category">Web3 Gaming</div>
                    <h3>Netvrk Metaverse</h3>
                    <p>Rigged and animated quadruped creatures for Web3 metaverse</p>
                    <div class="project-tech">
                        <span class="tech-tag">Unreal Engine</span>
                        <span class="tech-tag">Animation</span>
                        <span class="tech-tag">Rigging</span>
                        <span class="tech-tag">Maya</span>
                    </div>
                </div>
            </div>

            <div class="project-card">
                <div class="project-card-image">
                    <img src="images/UE_web.jpg" alt="Unreal Engine 5">
                </div>
                <div class="project-card-content">
                    <div class="project-category">Engine Development</div>
                    <h3>Unreal Engine 5 QA</h3>
                    <p>Build health and test automation for UE5 early development</p>
                    <div class="project-tech">
                        <span class="tech-tag">Test Execution</span>
                        <span class="tech-tag">Perforce</span>
                        <span class="tech-tag">Unreal Engine</span>
                        <span class="tech-tag">Linux</span>
                    </div>
                </div>
            </div>

            <div class="project-card">
                <div class="project-card-image">
                    <img src="images/FRN_web.jpg" alt="FREN Inc">
                </div>
                <div class="project-card-content">
                    <div class="project-category">Educational</div>
                    <h3>Children's Museum Characters</h3>
                    <p>Modeled, textured, and rigged characters for Telfair Museums</p>
                    <div class="project-tech">
                        <span class="tech-tag">Maya</span>
                        <span class="tech-tag">3D Character Modeling</span>
                        <span class="tech-tag">Rigging</span>
                        <span class="tech-tag">Animation Supervisor</span>
                    </div>
                </div>
            </div>
        </div>
    </section>

    <footer>
        <p>&copy; 2025 Jesse Zumstein. All rights reserved.</p>
    </footer>
    </div>

    <script>
        // Simple filter functionality
        const filterBtns = document.querySelectorAll('.filter-btn');
        
        filterBtns.forEach(btn => {
            btn.addEventListener('click', () => {
                filterBtns.forEach(b => b.classList.remove('active'));
                btn.classList.add('active');
                // In a real implementation, this would filter the projects
            });
        });

        // Interactive Title Effect
        const mainTitle = document.getElementById('mainTitle');
        
        mainTitle.addEventListener('mousemove', (e) => {
            const rect = mainTitle.getBoundingClientRect();
            const x = ((e.clientX - rect.left) / rect.width) * 100;
            const y = ((e.clientY - rect.top) / rect.height) * 100;
            
            mainTitle.style.setProperty('--mouse-x', `${x}%`);
            mainTitle.style.setProperty('--mouse-y', `${y}%`);
        });

        // Hero Particle Canvas Animation
        const heroCanvas = document.getElementById('heroCanvas');
        const heroCtx = heroCanvas.getContext('2d');
        
        heroCanvas.width = heroCanvas.offsetWidth;
        heroCanvas.height = heroCanvas.offsetHeight;

        let heroMouse = {
            x: heroCanvas.width / 2,
            y: heroCanvas.height / 2
        };

        class HeroParticle {
            constructor() {
                this.x = Math.random() * heroCanvas.width;
                this.y = Math.random() * heroCanvas.height;
                this.size = Math.random() * 3 + 1;
                this.baseX = this.x;
                this.baseY = this.y;
                this.density = (Math.random() * 30) + 1;
                this.distance = 0;
                this.vx = (Math.random() - 0.5) * 0.5;
                this.vy = (Math.random() - 0.5) * 0.5;
            }

            draw() {
                heroCtx.fillStyle = `rgba(102, 126, 234, ${1 - this.distance / 200})`;
                heroCtx.beginPath();
                heroCtx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
                heroCtx.closePath();
                heroCtx.fill();
            }

            update() {
                let dx = heroMouse.x - this.x;
                let dy = heroMouse.y - this.y;
                this.distance = Math.sqrt(dx * dx + dy * dy);
                let forceDirectionX = dx / this.distance;
                let forceDirectionY = dy / this.distance;
                let maxDistance = 150;
                let force = (maxDistance - this.distance) / maxDistance;
                let directionX = forceDirectionX * force * this.density;
                let directionY = forceDirectionY * force * this.density;

                if (this.distance < maxDistance) {
                    this.x -= directionX;
                    this.y -= directionY;
                } else {
                    if (this.x !== this.baseX) {
                        let dx = this.x - this.baseX;
                        this.x -= dx / 10;
                    }
                    if (this.y !== this.baseY) {
                        let dy = this.y - this.baseY;
                        this.y -= dy / 10;
                    }
                }

                this.baseX += this.vx;
                this.baseY += this.vy;

                if (this.baseX < 0 || this.baseX > heroCanvas.width) {
                    this.vx = -this.vx;
                    this.baseX = Math.max(0, Math.min(heroCanvas.width, this.baseX));
                }
                if (this.baseY < 0 || this.baseY > heroCanvas.height) {
                    this.vy = -this.vy;
                    this.baseY = Math.max(0, Math.min(heroCanvas.height, this.baseY));
                }
            }
        }

        let heroParticlesArray = [];
        const numberOfHeroParticles = 100;

        function initHero() {
            heroParticlesArray = [];
            for (let i = 0; i < numberOfHeroParticles; i++) {
                heroParticlesArray.push(new HeroParticle());
            }
        }

        function connectHeroParticles() {
            for (let a = 0; a < heroParticlesArray.length; a++) {
                for (let b = a; b < heroParticlesArray.length; b++) {
                    let dx = heroParticlesArray[a].x - heroParticlesArray[b].x;
                    let dy = heroParticlesArray[a].y - heroParticlesArray[b].y;
                    let distance = Math.sqrt(dx * dx + dy * dy);

                    if (distance < 100) {
                        heroCtx.strokeStyle = `rgba(102, 126, 234, ${1 - distance / 100})`;
                        heroCtx.lineWidth = 0.5;
                        heroCtx.beginPath();
                        heroCtx.moveTo(heroParticlesArray[a].x, heroParticlesArray[a].y);
                        heroCtx.lineTo(heroParticlesArray[b].x, heroParticlesArray[b].y);
                        heroCtx.stroke();
                    }
                }
            }
        }

        function animateHero() {
            heroCtx.clearRect(0, 0, heroCanvas.width, heroCanvas.height);

            for (let i = 0; i < heroParticlesArray.length; i++) {
                heroParticlesArray[i].update();
                heroParticlesArray[i].draw();
            }
            connectHeroParticles();
            requestAnimationFrame(animateHero);
        }

        initHero();
        animateHero();

        heroCanvas.addEventListener('mousemove', (e) => {
            const rect = heroCanvas.getBoundingClientRect();
            heroMouse.x = e.clientX - rect.left;
            heroMouse.y = e.clientY - rect.top;
        });

        // Grid Canvas Background for Content Sections
        const projectsCanvas = document.getElementById('projectsCanvas');
        const projectsCtx = projectsCanvas.getContext('2d');
        const canvasWrapper = projectsCanvas.parentElement;
        
        function updateCanvasSize() {
            projectsCanvas.width = window.innerWidth;
            // Get the actual height of the wrapper div containing all content sections
            projectsCanvas.height = canvasWrapper.offsetHeight;
        }
        
        updateCanvasSize();

        let gridMouse = { x: 0, y: 0 };
        
        document.addEventListener('mousemove', (e) => {
            const wrapperRect = canvasWrapper.getBoundingClientRect();
            gridMouse.x = e.clientX;
            gridMouse.y = e.clientY - wrapperRect.top;
        });

        class GridNode {
            constructor(x, y) {
                this.x = x;
                this.y = y;
                this.baseSize = 2;
                this.size = this.baseSize;
                this.maxSize = 8;
            }

            draw() {
                const dx = gridMouse.x - this.x;
                const dy = gridMouse.y - this.y;
                const distance = Math.sqrt(dx * dx + dy * dy);
                const maxDistance = 200;

                if (distance < maxDistance) {
                    this.size = this.baseSize + (1 - distance / maxDistance) * this.maxSize;
                    const opacity = 1 - distance / maxDistance;
                    projectsCtx.fillStyle = `rgba(102, 126, 234, ${opacity * 0.8})`;
                    projectsCtx.shadowBlur = 15;
                    projectsCtx.shadowColor = 'rgba(102, 126, 234, 0.5)';
                } else {
                    this.size = this.baseSize;
                    projectsCtx.fillStyle = 'rgba(102, 126, 234, 0.3)';
                    projectsCtx.shadowBlur = 0;
                }

                projectsCtx.beginPath();
                projectsCtx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
                projectsCtx.fill();
            }
        }

        const gridSpacing = 80;
        let gridNodes = [];
        
        function initGrid() {
            gridNodes = [];
            for (let x = gridSpacing; x < projectsCanvas.width; x += gridSpacing) {
                for (let y = gridSpacing; y < projectsCanvas.height; y += gridSpacing) {
                    gridNodes.push(new GridNode(x, y));
                }
            }
        }
        
        // Initialize after a short delay to ensure page is loaded
        setTimeout(() => {
            updateCanvasSize();
            initGrid();
        }, 100);

        function animateGrid() {
            projectsCtx.clearRect(0, 0, projectsCanvas.width, projectsCanvas.height);

            // Draw grid lines
            projectsCtx.strokeStyle = 'rgba(102, 126, 234, 0.1)';
            projectsCtx.lineWidth = 1;
            
            for (let x = gridSpacing; x < projectsCanvas.width; x += gridSpacing) {
                projectsCtx.beginPath();
                projectsCtx.moveTo(x, 0);
                projectsCtx.lineTo(x, projectsCanvas.height);
                projectsCtx.stroke();
            }
            
            for (let y = gridSpacing; y < projectsCanvas.height; y += gridSpacing) {
                projectsCtx.beginPath();
                projectsCtx.moveTo(0, y);
                projectsCtx.lineTo(projectsCanvas.width, y);
                projectsCtx.stroke();
            }

            // Draw nodes
            gridNodes.forEach(node => node.draw());

            requestAnimationFrame(animateGrid);
        }

        animateGrid();

        // Handle resize
        window.addEventListener('resize', () => {
            heroCanvas.width = heroCanvas.offsetWidth;
            heroCanvas.height = heroCanvas.offsetHeight;
            initHero();

            updateCanvasSize();
            initGrid();
        });
        
        // Also reinitialize on window load to ensure proper sizing
        window.addEventListener('load', () => {
            updateCanvasSize();
            initGrid();
        });

        // Rive Animation - Proper State Machine Integration
        let riveInstance = null;
        let stateMachineInputs = {};
        let viewModelInstance = null;
        let viewModelProperties = {};

        function initRive() {
            const canvas = document.getElementById('rive-canvas');
            const loadingEl = document.getElementById('rive-loading');
            
            if (!canvas) return;

            const container = canvas.parentElement;
            canvas.width = container.offsetWidth || 500;
            canvas.height = container.offsetHeight || 400;

            riveInstance = new rive.Rive({
                src: 'images/duo_prototype.riv',
                canvas: canvas,
                artboard: 'Main',
                autoplay: false,
                // DON'T specify stateMachines here - we'll add it manually after setting inputs
                fit: rive.Fit.Cover,
                alignment: rive.Alignment.Center,
                automaticallyHandleEvents: true,
                shouldDisableRiveListeners: false,
                onLoad: () => {
                    if (loadingEl) loadingEl.style.display = 'none';
                    riveInstance.resizeDrawingSurfaceToCanvas();
                    
                    console.log('=== RIVE LOADED ===');
                    console.log('Artboard:', riveInstance.artboardName);
                    console.log('State Machines available:', riveInstance.stateMachineNames);
                    console.log('Animations:', riveInstance.animationNames);
                    
                    // Bind ViewModel first
                    bindViewModel();
                    
                    // Get the initial planIndex value
                    const vmPlanIndex = getViewModelNumber('planIndex') ?? 0;
                    console.log('Initial planIndex from ViewModel:', vmPlanIndex);
                    
                    // Now manually instantiate the state machine
                    // This allows us to set inputs before it starts evaluating
                    requestAnimationFrame(() => {
                        // Play the state machine - this instantiates it
                        riveInstance.play('SM_Background');
                        
                        // Immediately get and set the input
                        const inputs = riveInstance.stateMachineInputs('SM_Background');
                        if (inputs) {
                            inputs.forEach(input => {
                                stateMachineInputs[input.name] = input;
                                console.log(`State Machine Input: ${input.name} (type: ${getInputTypeName(input.type)}, value: ${input.value})`);
                                
                                // Set localPlanIndex to match ViewModel
                                if (input.name === 'localPlanIndex') {
                                    input.value = vmPlanIndex;
                                    lastSyncedPlanIndex = vmPlanIndex;
                                    console.log(`Set localPlanIndex to ${vmPlanIndex}`);
                                }
                            });
                        }
                        
                        console.log('Playing state machines:', riveInstance.playingStateMachineNames);
                        
                        // Start polling to sync ViewModel changes
                        startPlanIndexSync();
                    });
                },
                onLoadError: (err) => {
                    console.error('Rive load error:', err);
                    if (loadingEl) {
                        loadingEl.textContent = 'Failed to load prototype';
                        loadingEl.classList.add('rive-error');
                    }
                },
                onStateChange: (event) => {
                    // This fires when the state machine transitions between states
                    console.log('State Machine Transition:', event.data);
                },
                onRiveEvent: (event) => {
                    // This fires for Rive Events defined in the editor
                    console.log('Rive Event:', event);
                }
            });
        }
        
        // Get human-readable input type name
        function getInputTypeName(type) {
            switch(type) {
                case rive.StateMachineInputType.Boolean: return 'Boolean';
                case rive.StateMachineInputType.Number: return 'Number';
                case rive.StateMachineInputType.Trigger: return 'Trigger';
                default: return 'Unknown';
            }
        }
        
        // Bind ViewModel for data-driven animations
        function bindViewModel() {
            try {
                const artboard = riveInstance.artboard;
                
                // Method 1: Try to get the artboard's DEFAULT ViewModel instance
                // This is the instance already configured in the Rive editor
                if (artboard && typeof artboard.defaultViewModelInstance === 'function') {
                    viewModelInstance = artboard.defaultViewModelInstance();
                    if (viewModelInstance) {
                        console.log('Using artboard default ViewModel instance');
                        cacheViewModelProperties();
                        return;
                    }
                }
                
                // Method 2: Try viewModelInstance property directly
                if (artboard && artboard.viewModelInstance) {
                    viewModelInstance = artboard.viewModelInstance;
                    console.log('Using artboard.viewModelInstance');
                    cacheViewModelProperties();
                    return;
                }
                
                // Method 3: Fall back to manual binding from riveFile
                const rf = riveInstance.riveFile;
                if (!rf || !rf.file) {
                    console.log('No riveFile available for ViewModel binding');
                    return;
                }
                
                // Try to find and bind StatsVM
                const viewModel = rf.file.viewModelByName('StatsVM');
                if (!viewModel) {
                    console.log('ViewModel "StatsVM" not found');
                    return;
                }
                
                console.log('ViewModel instanceCount:', viewModel.instanceCount);
                
                // Try to get or create an instance
                if (viewModel.instanceCount > 0) {
                    viewModelInstance = viewModel.instanceByIndex(0);
                } else if (typeof viewModel.defaultInstance === 'function') {
                    viewModelInstance = viewModel.defaultInstance();
                } else if (typeof viewModel.createDefaultInstance === 'function') {
                    viewModelInstance = viewModel.createDefaultInstance();
                }
                
                if (!viewModelInstance) {
                    console.log('Could not get ViewModel instance');
                    return;
                }
                
                // Bind the ViewModel instance to the artboard
                if (artboard && typeof artboard.bindViewModelInstance === 'function') {
                    // Get the native/runtime instance for binding
                    const nativeInstance = viewModelInstance.nativeInstance || 
                                          viewModelInstance.runtimeInstance || 
                                          viewModelInstance;
                    artboard.bindViewModelInstance(nativeInstance);
                    console.log('ViewModel "StatsVM" manually bound to artboard');
                }
                
                // Cache references to ViewModel properties for observation
                cacheViewModelProperties();
                
            } catch (e) {
                console.log('ViewModel binding error:', e.message);
                console.error(e);
            }
        }
        
        // Cache ViewModel property references
        function cacheViewModelProperties() {
            if (!viewModelInstance) return;
            
            try {
                // Cache number properties
                if (typeof viewModelInstance.number === 'function') {
                    const planIndex = viewModelInstance.number('planIndex');
                    if (planIndex) {
                        viewModelProperties.planIndex = planIndex;
                        console.log('ViewModel property "planIndex":', planIndex.value);
                    }
                }
                
                // Cache boolean properties (hover states, etc.)
                if (typeof viewModelInstance.boolean === 'function') {
                    ['maxHover', 'superHover', 'basicHover'].forEach(name => {
                        const prop = viewModelInstance.boolean(name);
                        if (prop) {
                            viewModelProperties[name] = prop;
                            console.log(`ViewModel property "${name}":`, prop.value);
                        }
                    });
                }
            } catch (e) {
                console.log('ViewModel property caching note:', e.message);
            }
        }

        // === STATE MACHINE INPUT HELPERS ===
        // Use these to interact with the state machine properly
        
        // Set a boolean input value
        function setBooleanInput(inputName, value) {
            const input = stateMachineInputs[inputName];
            if (input && input.type === rive.StateMachineInputType.Boolean) {
                input.value = value;
                console.log(`Set boolean "${inputName}" to ${value}`);
            } else {
                console.warn(`Boolean input "${inputName}" not found`);
            }
        }

        // Fire a trigger input
        function fireTrigger(inputName) {
            const input = stateMachineInputs[inputName];
            if (input && input.type === rive.StateMachineInputType.Trigger) {
                input.fire();
                console.log(`Fired trigger "${inputName}"`);
            } else {
                console.warn(`Trigger input "${inputName}" not found`);
            }
        }

        // Set a number input value
        function setNumberInput(inputName, value) {
            const input = stateMachineInputs[inputName];
            if (input && input.type === rive.StateMachineInputType.Number) {
                input.value = value;
                console.log(`Set number "${inputName}" to ${value}`);
            } else {
                console.warn(`Number input "${inputName}" not found`);
            }
        }
        
        // Get current value of an input
        function getInputValue(inputName) {
            const input = stateMachineInputs[inputName];
            if (input) {
                return input.value;
            }
            return undefined;
        }
        
        // === VIEWMODEL PROPERTY HELPERS ===
        // Use these to read/write ViewModel data
        
        function getViewModelNumber(propName) {
            const prop = viewModelProperties[propName];
            return prop ? prop.value : undefined;
        }
        
        function setViewModelNumber(propName, value) {
            const prop = viewModelProperties[propName];
            if (prop) {
                prop.value = value;
                console.log(`Set ViewModel "${propName}" to ${value}`);
                
                // Auto-sync planIndex to localPlanIndex for SM_Background
                // Use debounced sync to prevent rapid-fire state machine updates
                if (propName === 'planIndex') {
                    if (syncDebounceTimer) clearTimeout(syncDebounceTimer);
                    syncDebounceTimer = setTimeout(() => {
                        syncLocalPlanIndex(true); // force sync
                    }, 50);
                }
            }
        }
        
        // === PLANINDEX SYNC FOR SM_BACKGROUND ===
        // Syncs ViewModel's planIndex to SM_Background's localPlanIndex input
        
        let lastSyncedPlanIndex = null;
        let planIndexSyncInterval = null;
        let syncDebounceTimer = null;
        let isSyncing = false;
        
        function syncLocalPlanIndex(force = false) {
            // Prevent re-entry during sync
            if (isSyncing && !force) return;
            
            const vmPlanIndex = getViewModelNumber('planIndex');
            const localInput = stateMachineInputs['localPlanIndex'];
            
            if (!localInput || vmPlanIndex === undefined) return;
            
            // Only sync if the actual input value is different from what we want
            const currentInputValue = localInput.value;
            
            if (currentInputValue !== vmPlanIndex) {
                isSyncing = true;
                localInput.value = vmPlanIndex;
                lastSyncedPlanIndex = vmPlanIndex;
                console.log(`Synced localPlanIndex: ${currentInputValue} â†’ ${vmPlanIndex}`);
                
                // Prevent rapid re-sync for 500ms after a sync
                setTimeout(() => {
                    isSyncing = false;
                }, 500);
            } else {
                // Values match, just update tracking
                lastSyncedPlanIndex = vmPlanIndex;
            }
        }
        
        function startPlanIndexSync() {
            // Poll every 250ms to catch ViewModel changes from Rive listeners
            // Using longer interval to reduce performance impact and prevent loops
            if (planIndexSyncInterval) {
                clearInterval(planIndexSyncInterval);
            }
            
            planIndexSyncInterval = setInterval(() => {
                syncLocalPlanIndex();
            }, 250);
            
            console.log('Started planIndex sync polling (250ms)');
        }
        
        function stopPlanIndexSync() {
            if (planIndexSyncInterval) {
                clearInterval(planIndexSyncInterval);
                planIndexSyncInterval = null;
                console.log('Stopped planIndex sync polling');
            }
        }
        
        function getViewModelBoolean(propName) {
            const prop = viewModelProperties[propName];
            return prop ? prop.value : undefined;
        }
        
        function setViewModelBoolean(propName, value) {
            const prop = viewModelProperties[propName];
            if (prop) {
                prop.value = value;
                console.log(`Set ViewModel "${propName}" to ${value}`);
            }
        }

        // Handle window resize for Rive canvas
        window.addEventListener('resize', () => {
            if (riveInstance) {
                const canvas = document.getElementById('rive-canvas');
                const container = canvas.parentElement;
                canvas.width = container.offsetWidth;
                canvas.height = container.offsetHeight;
                riveInstance.resizeDrawingSurfaceToCanvas();
            }
        });
        
        // Expose helpers globally for debugging in console
        window.riveHelpers = {
            setBooleanInput,
            fireTrigger,
            setNumberInput,
            getInputValue,
            getViewModelNumber,
            setViewModelNumber,
            getViewModelBoolean,
            setViewModelBoolean,
            syncLocalPlanIndex,
            startPlanIndexSync,
            stopPlanIndexSync,
            getInstance: () => riveInstance,
            getInputs: () => stateMachineInputs,
            getViewModel: () => viewModelInstance,
            getViewModelProps: () => viewModelProperties
        };

        // Initialize Rive when the page loads
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', initRive);
        } else {
            initRive();
        }
    </script>
</body>
</html>